# -*- coding: utf-8 -*-
"""models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UXsrMEcnvWY0Nu25lq7YqfJGWoxuzlCG
"""

import sklearn
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, SGDRegressor
import matplotlib.pyplot as plt
import sklearn.metrics as metrics
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.neural_network import MLPRegressor
from sklearn.ensemble import RandomForestRegressor
import pickle
# sklearn.linear_model.SGDRegressor

crypto_to_symbol = {'doge': 'DOGE', 'avax': 'AVAX', 'matic' : 'MATIC', 'ripple': 'XRP', 'shiba' : 'SHIB', 'solana' : 'SOL'}

crypto = "solana"

sentiment_df = pd.read_csv(f"./sentiments/{crypto}_sentiment.csv")

sentiment_df.shape

sentiment_df.columns

sentiment_df

sentiment_df.dtypes

# sentiment_df.loc[sentiment_df["sentiment_label"] == "positive", "sentiment_label"] = 1
# sentiment_df.loc[sentiment_df["sentiment_label"] == "negative", "sentiment_label"] = -1
# sentiment_df.loc[sentiment_df["sentiment_label"] == "neutral", "sentiment_label"] = 0

sentiment_df.loc[sentiment_df["user_verified"] == 'True', "user_verified"] = 1
sentiment_df.loc[sentiment_df["user_verified"] == 'False', "user_verified"] = 0

sentiment_df["positive_score"] = 0
sentiment_df["negative_score"] = 0
sentiment_df["neutral_score"] = 0

sentiment_df['positive_score'] = np.where(sentiment_df.sentiment_label == 'positive', sentiment_df.sentiment_score, 0)
sentiment_df['negative_score'] = np.where(sentiment_df.sentiment_label == 'negative', sentiment_df.sentiment_score, 0)
sentiment_df['neutral_score'] = np.where(sentiment_df.sentiment_label == 'neutral', sentiment_df.sentiment_score, 0)

sentiment_df['avg_price'] = (sentiment_df.high + sentiment_df.low)/2
# sentiment_df = sentiment_df.astype({"user_verified":str})

"""Models"""

sentiment_df_copy = sentiment_df.copy(deep=True)

enc = OneHotEncoder(sparse=False)
color_onehot = enc.fit_transform(sentiment_df_copy[['sentiment_label']])

# enc_2 = OneHotEncoder(sparse=False)
# verif_onehot = enc_2.fit_transform(sentiment_df_copy[['user_verified']])

sentiment_labels = pd.DataFrame(color_onehot, columns=list(enc.categories_[0]))
# verif_labels = pd.DataFrame(verif_onehot, columns=['not_verified', 'verified'])
# print(verif_labels)
sentiment_df_copy = pd.concat([sentiment_df_copy, sentiment_labels], axis=1)

sentiment_df_copy.columns

# sentiment_df_copy.drop(columns=['sentiment_score'])
sentiment_df_copy = sentiment_df_copy.reset_index()
sentiment_df_copy.dropna(inplace=True)

# sentiment_df_copy.isnull().values.any()
sentiment_df_copy.isnull().sum().sum()

model_data = np.array(sentiment_df_copy[['favourite_count', 'retweet_count', 'user_followers_count', 'user_verified', 'negative', 'neutral', 'positive', 'positive_score', 'negative_score', 'neutral_score', 'avg_price']])
model_data.shape



if(crypto == 'avax'):
    model_data = np.delete(model_data, 20642, 0)

model_data = model_data.astype(float)

model_data[0]

feature_data = model_data[:, :10]
print(feature_data.shape)
y_price = model_data[:, 10:]
print(y_price.shape)

feature_data[0]

test_size = 0.3
total_samples = feature_data.shape[0]
test_samples = int(0.3 * total_samples)
train_samples = total_samples - test_samples

train_x = feature_data[:train_samples, :]
test_x = feature_data[train_samples:,:]
train_y = y_price[:train_samples]
test_y = y_price[train_samples:]

# train_x, test_x, train_y, test_y = train_test_split(feature_data, y_price, shuffle=False, test_size=0.3)

# # Standar Scaler
scaler = StandardScaler()
scaled_train_x = scaler.fit_transform(train_x)
scaled_test_x = scaler.transform(test_x)

# # MinMax Scaler
# scaler = MinMaxScaler()
# scaled_train_x = scaler.fit_transform(train_x)
# scaled_test_x = scaler.transform(test_x)

train_y = train_y.reshape((train_y.shape[0],))
test_y = test_y.reshape((test_y.shape[0],))
print(train_x.shape)
print(test_x.shape)
print(train_y.shape)
print(test_y.shape)

# train_x.astype(float)
train_x[0]

"""Linear Regression"""

model_lr = LinearRegression()
model_lr.fit(train_x, train_y)

y_pred = model_lr.predict(test_x)

print(y_pred)

df = pd.DataFrame({'Actual': test_y.flatten(), 'Predicted': y_pred.flatten()})
pd.set_option("display.precision", 20)
print(df)

print('Mean Absolute Error:', metrics.mean_absolute_error(test_y, y_pred))  
print('Mean Squared Error:', metrics.mean_squared_error(test_y, y_pred))  
print('Root Mean Squared Error:', np.sqrt(metrics.mean_squared_error(test_y, y_pred)))

model_path_1 = f'./saved_models/{crypto}/lr.sav'
pickle.dump(model_lr, open(model_path_1, 'wb'))

"""SGD Regressor"""

import sys
import io
import matplotlib.pyplot as plt

class DisplayLossCurve(object):
  def __init__(self, print_loss=False):
    self.print_loss = print_loss

  """Make sure the model verbose is set to 1"""
  def __enter__(self):
    self.old_stdout = sys.stdout
    sys.stdout = self.mystdout = io.StringIO()
  
  def __exit__(self, *args, **kwargs):
    sys.stdout = self.old_stdout
    loss_history = self.mystdout.getvalue()
    loss_list = []
    for line in loss_history.split('\n'):
      if(len(line.split("loss: ")) == 1):
        continue
      loss_list.append(float(line.split("loss: ")[-1]))
    plt.figure()
    plt.plot(np.arange(len(loss_list)), loss_list)
    plt.xlabel("Epoch")
    plt.ylabel("Loss")
    plt.savefig(f'./loss_curves/{crypto}_loss.png', bbox_inches='tight', facecolor='w')

    if self.print_loss:
      print("=============== Loss Array ===============")
      print(np.array(loss_list))
      
    return True

model_sgd = SGDRegressor(loss='huber', alpha=0.01, penalty='l2', max_iter=100, learning_rate='adaptive', eta0=0.01, verbose=1, early_stopping=True)

with DisplayLossCurve(print_loss=True):
    model_sgd.fit(scaled_train_x, train_y)

preds = model_sgd.predict(scaled_test_x)

preds

print('Mean Absolute Error:', metrics.mean_absolute_error(test_y, preds))  
print('Mean Squared Error:', metrics.mean_squared_error(test_y, preds))  
print('Root Mean Squared Error:', np.sqrt(metrics.mean_squared_error(test_y, preds)))
print('R2 Score : ', metrics.r2_score(preds, test_y))

model_path_2 = f'./saved_models/{crypto}/sgd.sav'
pickle.dump(model_sgd, open(model_path_2, 'wb'))

"""RF Regressor"""

rf_regressor = RandomForestRegressor(max_depth=5, random_state=42)

rf_regressor.fit(train_x, train_y)

rf_preds = rf_regressor.predict(test_x)

print('Mean Absolute Error:', metrics.mean_absolute_error(test_y, rf_preds))  
print('Mean Squared Error:', metrics.mean_squared_error(test_y, rf_preds))  
print('Root Mean Squared Error:', np.sqrt(metrics.mean_squared_error(test_y, rf_preds)))
# print('R2 Score : ', metrics.r2_score(rf_preds, test_y))

model_path_3 = f'./saved_models/{crypto}/rf.sav'
pickle.dump(rf_regressor, open(model_path_3, 'wb'))